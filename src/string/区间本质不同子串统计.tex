\paragraph{问题} 给定一个字符串 $s$，多次询问 $[l, r]$ 区间的本质不同的子串个数，可能强制在线。

\paragraph{做法} 考虑建出后缀自动机，然后枚举右端点，用线段树维护每个左端点的答案。

显然只有 \texttt{right} 集合在 $[l, r]$ 中的串才有可能有贡献，所以我们可以只考虑每个串最大的 \texttt{right}。

每次右端点 + 1 时找到它对应的结点 $u$，则 $u$ 到根节点路径上的每个点，它的 \texttt{right} 集合都会被 $r$ 更新。

对于某个特定的左端点 $l$，我们需要保证本质不同的子串左端点不能越过它；因此对于一个结点 $p$，我们知道它对应的子串长度 $(val_{par_p}, val_p]$ 之后，在 $p$ 的 \texttt{right} 集合最大值减去对应长度，这样对应的 $l$ 内全部 + 1 即可。这样询问时就只需要查询 $r$ 对应的线段树中 $[l, r]$ 的区间和了。（当然旧的 \texttt{right} 对应的区间也要减掉）

实际上可以发现更新时都是把路径分成若干个整段更新 \texttt{right} 集合，因此可以用 LCT 维护这个过程。

时间复杂度 $O(n\log ^ 2 n)$，空间$O(n)$。当然如果强制在线的话，就把线段树改成主席树，空间复杂度就和时间复杂度同阶了。

\inputminted{cpp}{../src/string/samlct.cpp}

还有一份完整的代码，因为写起来确实细节挺多的。这份代码支持在尾部加一个字符或者询问区间有多少子串至少出现了 \textbf{两次}，并且强制在线。

\inputminted{cpp}{../src/string/samlct2.cpp}
